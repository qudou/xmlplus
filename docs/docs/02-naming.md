# 命名

## 一个示例

在探讨组件对象的命名之前，先看一个示例，后面的讲述主要围绕这个示例来展开。

```js
// 02-01
Index: {
   css: "#dog { color: red; }\
         #cat { color: blue; }\
         #animal { background: green; }",
   xml: "<div>\
             <h1 id='dog'>dog</h1>\
             <h1 id='cat'>cat</h1>\
         </div>",
   ali: { animal: "/div/h1" },
   fun: function (sys, items, opts) {
       console.log(sys.dog.text());
       console.log(sys.cat.text());
       sys.animal.call("css", "border", "1px solid black");
   }
}
```

此示例中存在一个名称为 Index 的组件，它包含了四个组成部分。其中视图项包含了要显示的对象，样式项包含了相关对象的样式，别名项是对集体对象的描述，函数项包含了相关的操作代码。

## 给个体对象命名

示例中，视图项包含三个 HTML 元素对象，其中两个都拥有 `id` 属性，其属性值分别为 `dog` 和 `cat`，我们把 `dog` 看作是第一个 h1 元素对象的名字，把 `cat` 看作是第二个 h1 元素对象的名字，而 div 则是一个未命名的元素对象。

所以，要给某一组件对象命名，只要给其相应的元素对象设定 `id` 属性就可以了。下面给出一些命名方面的建议。

- 名称中只包含字母、数字或下划线，且不能以数字开头
- 所取名字做到见名思义
- 确保各个元素的名称在视图项中不是冲突的

其中头两条规定不是强制性的，但遵守它们有助于书写更好的代码。如果违反第三条规定，则只有同名的最后一个对象才可以通过名称访问。

在程序运行时，视图项中的任何已命名节点都会实例化为对象。对于那些没有命名的节点也是如此。虽然，对于未命名节点的相应组件对象无法直接显示使用，但我们完全有办法获得并使用它，在后面章节中将会看到这点是如何做到的。

## 给集体对象命名

众多的个体对象聚合在一起形成集体对象。从整体的角度来看，集体对象包含有别于个体对象的独有性质，所以给集体对象命名有其必要性。下面来看如何给集体对象命名。

给集体对象命名时，首先需要懂得如何描述集体对象。集体对象的描述方式有很多种，可以是正则表达式或者 XPath 表达式，又或者是 css 选择器。对于用 XML 描述的对象集而言，使用专门配套的 XPath 表达式或者 css 选择器显然更好些。系统仅出于下面的理由，选择 XPath 表达式作为集体对象的描述。相对于 css 选择器，xpath 表达式的表达能力更为强大。比如对于文本对象，css 选择器就没法选择出来。

示例中，注意别名项部分包含的 `animal` 选项，它的值是一个表示 div 元素子级的 XPath 表达式 `/div/h1`，该表达式以文档根为上下文。于是 `animal` 代表了 `dog` 和 `cat` 所组成的集体对象。集体对象类似于数组，它包含了表达式所描述的所有的个体对象，它拥有属于自己的接口属性。

## 在样式项中使用命名对象

在示例中，可以看到这样两行 css 字符串：

```css
#dog { color: red; }
#cat { color: blue; }
```

此处，首行引用了组件对象 `dog`，并设置其字体颜色为红色；尾行引用了组件对象 `cat`，并设置其字体颜色为蓝色。

从这里可以看出，在样式项中引用个体对象的方式是：以 `#` 开头，再追加上个体对象名。这与通常做网页开发时，对拥有 `id` 属性的 HTML 元素的引用方式是一致的。

引用集体对象的方式与引用个体对象的方式是类似的，即以 `#` 开头，再追加上集体对象名。下面的样式将集体对象 `animal` 中的所有元素都加上了下划线。

```css
#animal { text-decoration: underline; } 
```

现在给视图项中的 div 元素对象也添加上名字属性，但删除组件的 `ali` 选项。如下代码所示, 那么在样式项中就存在另一种对集体对象的引用方式，它就是我们熟悉的包含选择符。它引用的集体对象所包含的元素与上面的组件对象 animal 是一样的。

```js
// 02-02
Index: {
   css: "#animal h1 { background: green; }",
   xml: "<div id='animal'>\
             <h1 id='dog'>dog</h1>\
             <h1 id='cat'>cat</h1>\
         </div>"
} 
```

有时候，会存在同名的集体对象和个体对象。这种情况下，个体对象具有优先权。也就是说，个体对象的样式会覆盖集体对象的样式。当然，如果出现了这种情况，说明你的组件设计出问题了，你需要重新审视你设计。

## 在函数项中使用命名对象

下面的两行来自示例的函数项。其中，`sys.dog` 和 `sys.cat` 分别引用了已命名的组件对象 `dog` 和 `cat`，并分别通过调用它们的接口函数 [text](/api#DOM_text) 来获取对象所包含的文本。

```js
console.log(sys.dog.text());
console.log(sys.cat.text());
```

函数项中引用个体对象的方式：以 `sys.` 开头，再追加上个体对象名。当然，如果读者没有遵守前面对元素的命名约定，即元素名中包含非 JavaScript 标识符，那么就只能以类似访问数组元素的方式进行对象的访问。现在假设 `sys` 中包含名为 `cat&` 的个体元素，那么引用该元素方式就只能是：`sys["cat&"]`。

在函数项中引用集体对象的方式与引用个体对象的方式是一致的。集体对象有一个函数 [call](/api#集合.call)，它的第一个参数是一个字符串，代表一个函数名，其后是所代表函数的实参列表。该函数会遍历集体对象所包含的所有个体对象，并调用指定的函数（如果存在的话）。

现在来看看示例中对集体对象的使用。

```js
sys.animal.call("css", "border", "1px solid black");
```

该语句会依次调用组件对象 `dog` 和 `cat`的接口函数 [css](/api#DOM.css)，该函数以 `border` 和 `1px solid black` 作为函数实参列表。该语句的执行效果等同于下面两个语句。

```js
sys.dog.css("border", "1px solid black");
sys.cat.css("border", "1px solid black");
```

与前一节类似，有时候，会存在同名的集体对象和个体对象 `animal`。这种情况下，个体对象将覆盖集体对象。也就是说，此时在函数项中是无法访问到集体对象的。

## 个体对象包含的两类接口

在示例中，读者一定还注意到了函数项部分包含的形参 `items`。`items` 与 `sys` 包含了同样多的个体对象与集体对象，并且名称完全相同。比如 `sys` 中包含了一个对象 dog，`items`也包含一个对象 dog，前者我们称之为系统对象，后者我们称之为与系统对象相关联的值对象，简称值对象。这两者的关系如下。

```js
sys.target.value() === items.target
```

也就是说系统对象函数 `value` 的返回值等于与系统对象相关联的值对象。

系统对象所包含的接口函数，叫做系统对象接口。虽然系统对象与值对象是一对一的，但它们包含的接口却不尽相同。前面的组件对象 `sys.dog`和 `sys.cat` 所调用的 [text](/api#DOM.text) 函数即属于系统对象接口的一种。下面给出了系统对象包含的其它部分接口函数名：

```
on | off | trigger | append | before | remove | value…… 
```

这些接口函数由框架系统提供，它们是系统级别的，任何被实例化的对象都会有。系统对象接口提供了诸如组件对象之间通信或者组件对象的添加、移除之类的功能。它们的使用方式后续章节会陆续讲述。

与系统对象类似，值对象所包含的接口，叫做值对象接口。值对象所提供的接口取决于具体的组件，对于所有基组件对象，它们的接口均为空。至于非基组件接口方面的内容后续会有章节详细讲述，这里暂且不表。

到目前为止，我们遇到到不少可能容易混淆的名词。现在将它们列出来，并作简要说明。

- 组件：应用的基本构造块，它是一个普通对象，它相当于面向对象编程语言里面的类或者模板
- 组件对象：组件实例化的结果，一个组件可以实例化出多个组件对象
- 系统对象：每一组件对象都对应一个系统对象，组件对象与系统对象可以同等看待
- 值对象：它可以由系统对象接口函数 `value` 的执行结果得到，也可以从函数项的第二个实参中得到
- 系统对象接口：系统对象所包含的接口函数
- 值对象接口：值对象所包含的接口函数

## 样式项中的通配符

为了了解样式项中符号 `#` 所代表的内容，先来看看最终由样式项生成的 css 代码（与实际的内容有略有出入，但大体一致）。

```css
.cadog { color: red; }
.cacat { color: blue; }
.caanimal { background: green; }
```

通过与样式项中的内容进行比对，可以发现符号 `#` 被替换成了字符串 `.ca`。再看看最终由视图项生成的 html 代码。

```html
<div>
    <h1 class='cadog caanimal'>dog</h1>
    <h1 class='cacat caanimal'>cat</h1>
</div> 
```

通过与视图项中的内容进行比对，可以发现原始的 `id` 属性不见了，代之以 `class` 属性。`class` 属性中的类名与样式项中的内容恰好是对应的。

除了符号 `#` 外，样式项中还允许存在一个通配符 `$`，该通配符与 `#` 的区别仅在于：后者比前者多一个句点。也就是说，如果上述的样式项中出现符号 `$`，那么 `$` 最终会被替换为 `ca`。

上述通配符有一个特性，对于同一个组件，不论实例化出多少对象，通配符所对应的字符串都是不变的。所以该字符串可以用于标识一个组件。

## 组件的封闭性

现在假设在同一个应用中，又定义了另一个组件，如下所示。也就是说，现在同一个应用中包含了两个不同的组件。

```js
Zoon: {
   css: "#dog { color: red; }\
         #cat { color: blue; }",
   xml: "<div id='zoon'>\
             <h1 id='dog'>dog</h1>\
             <h1 id='cat'>cat</h1>\
         </div>"
}
```

可以看出，该组件内部同样包含了名为 `dog` 和 `cat` 的组件对象。那么它们是否会和前面的定义和 `dog` 和 `cat` 组件对象冲突呢？这种担心是完全不必要的。因为在 xmlplus 中，组件内部对象具有良好的封闭性，对于一个已实例化的组件对象而言，除了它开放的接口，你是无法访问其任何内部元素的。